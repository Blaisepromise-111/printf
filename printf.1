.\" Automatically generated by Pandoc 2.5
.\"
.TH "" "" "" "" ""
.hy
.PP
\&.TH man 3 \[lq]19 May 2022\[rq] \[lq]hk1.0\[rq] \[dq]_printf man
page\[dq]
.PP
\&.SH AUTHOR \[lq]Otitoola Olufolabi\[rq] \[lq]Sikiru Ademola\[rq]
.PP
\&.SH NAME
.PP
\&.B _printf
.PP
\- function to print formatted output of arguments
.PP
\&.SH SYNOPSIS
.PP
#include \[lq]main.h\[rq]
.PP
int _printf(const char *format, \&...);
.PP
\&.B _printf
.PP
\&.RI {FORMAT}
.PP
\&.RI [ARGUMENTS]\&...
.PP
\&.SH DESCRIPTION
.IP
.nf
\f[C]
The  functions  in the _printf family produce output according to a format as described below.  The functions _printf() write output to stdout,

the standard output stream.

The function write the output under the control of a format string that specifies how subsequent arguments (or arguments) are converted for output.
\f[R]
.fi
.PP
Format of the format string
.IP
.nf
\f[C]
   The format string is a character string, beginning and ending in its initial shift state, if any.  The format string is composed of zero or more  di\[hy]

   rectives:  ordinary  characters  (not  %),  which  are copied unchanged to the output stream; and conversion specifications, each of which results in

   fetching zero or more subsequent arguments.  Each conversion specification is introduced by the character %, and ends with  a  conversion  specifier.

   In the case of a double \[dq]%\[dq] i.e. \[dq]%%\[dq], the first \[dq]%\[dq] acts as an escape character for the second \[dq]%\[dq] and prints out only one \[dq]%\[dq] in the formated output.

   In between there may be (in this order) zero or more flags and subsequent arguments.



_printf(\[dq]%d\[dq], num);
\f[R]
.fi
.PP
Flag characters
.IP
.nf
\f[C]
   The character % is followed by zero or more of the following flags:
\f[R]
.fi
.PP
Conversion specifiers
.IP
.nf
\f[C]
   A character that specifies the type of conversion to be applied.  The conversion specifiers and their meanings are:



   d, i   The int argument is converted to signed decimal notation.  The precision, if any, gives the minimum number of digits that must appear; if  the

          converted  value  requires fewer digits, it is padded on the left with zeros.  The default precision is 1.  When 0 is printed with an explicit

          precision 0, the output is empty.



   o, u, x, X

          The unsigned int argument is converted to unsigned octal (o), unsigned decimal (u), or unsigned hexadecimal (x and X) notation.   The  letters

          abcdef  are  used for x conversions; the letters ABCDEF are used for X conversions.  The precision, if any, gives the minimum number of digits

          that must appear; if the converted value requires fewer digits, it is padded on the left with zeros.  The default precision is 1.  When  0  is

          printed with an explicit precision 0, the output is empty.



   c      If no l modifier is present, the int argument is converted to an unsigned char, and the resulting character is written.  If an l  modifier  is

          present,  the  wint_t  (wide  character) argument is converted to a multibyte sequence by a call to the wcrtomb(3) function, with a conversion

          state starting in the initial state, and the resulting multibyte string is written.



   s      If no l modifier is present: the const char * argument is expected to be a pointer to an array of character type (pointer to a string).  Char\[hy]

          acters from the array are written up to (but not including) a terminating null byte (\[aq]\[rs]0\[aq]); if a precision is specified, no more than the num\[hy]

          ber specified are written.  If a precision is given, no null byte need be present; if the precision is not specified, or is greater  than  the

          size of the array, the array must contain a terminating null byte.
\f[R]
.fi
.PP
\&.SH EXAMPLE
.PP
To print the address of Holberton School in the form \[dq]972 Mission
St., San
.PP
Francisco, CA 94103\[dq], followed by a new line, where , ,
.PP
and are pointers to strings:
.PP
\&.RS
.PP
#include \[lq]main.h\[rq]
.PP
int main(void)
.PP
{
.IP
.nf
\f[C]
char *street = \[dq]Mission St.\[dq];



char *city = \[dq]San Francisco\[dq],



char *state = \[dq]CA\[dq];



printf(\[dq]%d %s, %s, %s, %d\[rs]\[rs]n\[dq], 972, street, city, state, 94103);
\f[R]
.fi
.PP
}
.PP
\&.RE
.PP
To print the result of basic mathematical operations prepended by signs
and
.PP
all numbers printed with a minimum precision of two digits:
.PP
\&.RS
.PP
#include \[lq]main.h\[rq]
.PP
int main(void)
.PP
{
.IP
.nf
\f[C]
_printf(\[dq]%.2d + %.2d = %+.2d\[rs]\[rs]n\[dq], 1, 2, 1 + 2);



_printf(\[dq]%d \- %d = %+d\[rs]\[rs]n\[dq], 10, 20, 10 \- 20);
\f[R]
.fi
.PP
}
.PP
\&.SH RETURN VALUE
.IP
.nf
\f[C]
   Upon successful return, these functions return the number of characters printed which excludes the null byte used to end output for strings.
\f[R]
.fi
.PP
\&.B ARGUMENT
.IP "(s)" 4
according to
.PP
\&.B
.PP
\&.SH FORMAT
.PP
\&.SH Reporting Bugs
.IP
.nf
\f[C]
Report _printf bugs to https://github.com/Ade2002/printf/issues

    Code  such  as  _printf(foo);  often indicates a bug, since foo may contain a % character.  If foo comes from untrusted user input, it may contain %n,

    causing the _printf() call to write to memory and creating a security hole.
\f[R]
.fi
.PP
\&.SH Copyright
.IP
.nf
\f[C]
Copyright 2022

Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.

This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.
\f[R]
.fi
